{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/cpettyjohn/Habbo/instinct/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _slicedToArray from \"/Users/cpettyjohn/Habbo/instinct/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport locationHook from \"./use-location.js\";\nimport makeMatcher from \"./matcher.js\";\nimport { useRef, useLayoutEffect, useContext, useCallback, createContext, isValidElement, cloneElement, createElement as h } from \"./react-deps.js\";\n/*\n * Part 1, Hooks API: useRouter, useRoute and useLocation\n */\n// one of the coolest features of `createContext`:\n// when no value is provided â€” default object is used.\n// allows us to use the router context as a global ref to store\n// the implicitly created router (see `useRouter` below)\n\nvar RouterCtx = createContext({});\n\nvar buildRouter = function buildRouter() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$hook = _ref.hook,\n      hook = _ref$hook === void 0 ? locationHook : _ref$hook,\n      _ref$base = _ref.base,\n      base = _ref$base === void 0 ? \"\" : _ref$base,\n      _ref$matcher = _ref.matcher,\n      matcher = _ref$matcher === void 0 ? makeMatcher() : _ref$matcher;\n\n  return {\n    hook: hook,\n    base: base,\n    matcher: matcher\n  };\n};\n\nexport var useRouter = function useRouter() {\n  var globalRef = useContext(RouterCtx); // either obtain the router from the outer context (provided by the\n  // `<Router /> component) or create an implicit one on demand.\n\n  return globalRef.v || (globalRef.v = buildRouter());\n};\nexport var useLocation = function useLocation() {\n  var router = useRouter();\n  return router.hook(router);\n};\nexport var useRoute = function useRoute(pattern) {\n  var _useLocation = useLocation(),\n      _useLocation2 = _slicedToArray(_useLocation, 1),\n      path = _useLocation2[0];\n\n  return useRouter().matcher(pattern, path);\n}; // internal hook used by Link and Redirect in order to perform navigation\n\nvar useNavigate = function useNavigate(options) {\n  var navRef = useRef();\n\n  var _useLocation3 = useLocation(),\n      _useLocation4 = _slicedToArray(_useLocation3, 2),\n      navigate = _useLocation4[1];\n\n  navRef.current = function () {\n    return navigate(options.to || options.href, options);\n  };\n\n  return navRef;\n};\n/*\n * Part 2, Low Carb Router API: Router, Route, Link, Switch\n */\n\n\nexport var Router = function Router(props) {\n  var ref = useRef(); // this little trick allows to avoid having unnecessary\n  // calls to potentially expensive `buildRouter` method.\n  // https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily\n\n  var value = ref.current || (ref.current = {\n    v: buildRouter(props)\n  });\n  return h(RouterCtx.Provider, {\n    value: value,\n    children: props.children\n  });\n};\nexport var Route = function Route(_ref2) {\n  var path = _ref2.path,\n      match = _ref2.match,\n      component = _ref2.component,\n      children = _ref2.children;\n  var useRouteMatch = useRoute(path); // `props.match` is present - Route is controlled by the Switch\n\n  var _ref3 = match || useRouteMatch,\n      _ref4 = _slicedToArray(_ref3, 2),\n      matches = _ref4[0],\n      params = _ref4[1];\n\n  if (!matches) return null; // React-Router style `component` prop\n\n  if (component) return h(component, {\n    params: params\n  }); // support render prop or plain children\n\n  return typeof children === \"function\" ? children(params) : children;\n};\nexport var Link = function Link(props) {\n  var navRef = useNavigate(props);\n\n  var _useRouter = useRouter(),\n      base = _useRouter.base;\n\n  var to = props.to,\n      _props$href = props.href,\n      href = _props$href === void 0 ? to : _props$href,\n      children = props.children,\n      onClick = props.onClick;\n  var handleClick = useCallback(function (event) {\n    // ignores the navigation when clicked using right mouse button or\n    // by holding a special modifier key: ctrl, command, win, alt, shift\n    if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button !== 0) return;\n    event.preventDefault();\n    navRef.current();\n    onClick && onClick(event);\n  }, // navRef is a ref so it never changes\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [onClick]); // wraps children in `a` if needed\n\n  var extraProps = {\n    href: base + href,\n    onClick: handleClick,\n    to: null\n  };\n  var jsx = isValidElement(children) ? children : h(\"a\", props);\n  return cloneElement(jsx, extraProps);\n};\nexport var Switch = function Switch(_ref5) {\n  var children = _ref5.children,\n      location = _ref5.location;\n\n  var _useRouter2 = useRouter(),\n      matcher = _useRouter2.matcher;\n\n  var _useLocation5 = useLocation(),\n      _useLocation6 = _slicedToArray(_useLocation5, 1),\n      originalLocation = _useLocation6[0];\n\n  children = Array.isArray(children) ? children : [children];\n\n  var _iterator = _createForOfIteratorHelper(children),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var element = _step.value;\n      var match = 0;\n      if (isValidElement(element) && // we don't require an element to be of type Route,\n      // but we do require it to contain a truthy `path` prop.\n      // this allows to use different components that wrap Route\n      // inside of a switch, for example <AnimatedRoute />.\n      (match = element.props.path ? matcher(element.props.path, location || originalLocation) : [true, {}])[0]) return cloneElement(element, {\n        match: match\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return null;\n};\nexport var Redirect = function Redirect(props) {\n  var navRef = useNavigate(props); // empty array means running the effect once, navRef is a ref so it never changes\n\n  useLayoutEffect(function () {\n    navRef.current();\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return null;\n};\nexport default useRoute;","map":{"version":3,"sources":["/Users/cpettyjohn/Habbo/instinct/node_modules/wouter/index.js"],"names":["locationHook","makeMatcher","useRef","useLayoutEffect","useContext","useCallback","createContext","isValidElement","cloneElement","createElement","h","RouterCtx","buildRouter","hook","base","matcher","useRouter","globalRef","v","useLocation","router","useRoute","pattern","path","useNavigate","options","navRef","navigate","current","to","href","Router","props","ref","value","Provider","children","Route","match","component","useRouteMatch","matches","params","Link","onClick","handleClick","event","ctrlKey","metaKey","altKey","shiftKey","button","preventDefault","extraProps","jsx","Switch","location","originalLocation","Array","isArray","element","Redirect"],"mappings":"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","sourcesContent":["import locationHook from \"./use-location.js\";\nimport makeMatcher from \"./matcher.js\";\n\nimport {\n  useRef,\n  useLayoutEffect,\n  useContext,\n  useCallback,\n  createContext,\n  isValidElement,\n  cloneElement,\n  createElement as h,\n} from \"./react-deps.js\";\n\n/*\n * Part 1, Hooks API: useRouter, useRoute and useLocation\n */\n\n// one of the coolest features of `createContext`:\n// when no value is provided â€” default object is used.\n// allows us to use the router context as a global ref to store\n// the implicitly created router (see `useRouter` below)\nconst RouterCtx = createContext({});\n\nconst buildRouter = ({\n  hook = locationHook,\n  base = \"\",\n  matcher = makeMatcher(),\n} = {}) => ({ hook, base, matcher });\n\nexport const useRouter = () => {\n  const globalRef = useContext(RouterCtx);\n\n  // either obtain the router from the outer context (provided by the\n  // `<Router /> component) or create an implicit one on demand.\n  return globalRef.v || (globalRef.v = buildRouter());\n};\n\nexport const useLocation = () => {\n  const router = useRouter();\n  return router.hook(router);\n};\n\nexport const useRoute = (pattern) => {\n  const [path] = useLocation();\n  return useRouter().matcher(pattern, path);\n};\n\n// internal hook used by Link and Redirect in order to perform navigation\nconst useNavigate = (options) => {\n  const navRef = useRef();\n  const [, navigate] = useLocation();\n\n  navRef.current = () => navigate(options.to || options.href, options);\n  return navRef;\n};\n\n/*\n * Part 2, Low Carb Router API: Router, Route, Link, Switch\n */\n\nexport const Router = (props) => {\n  const ref = useRef();\n\n  // this little trick allows to avoid having unnecessary\n  // calls to potentially expensive `buildRouter` method.\n  // https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily\n  const value = ref.current || (ref.current = { v: buildRouter(props) });\n\n  return h(RouterCtx.Provider, {\n    value,\n    children: props.children,\n  });\n};\n\nexport const Route = ({ path, match, component, children }) => {\n  const useRouteMatch = useRoute(path);\n\n  // `props.match` is present - Route is controlled by the Switch\n  const [matches, params] = match || useRouteMatch;\n\n  if (!matches) return null;\n\n  // React-Router style `component` prop\n  if (component) return h(component, { params });\n\n  // support render prop or plain children\n  return typeof children === \"function\" ? children(params) : children;\n};\n\nexport const Link = (props) => {\n  const navRef = useNavigate(props);\n  const { base } = useRouter();\n\n  let { to, href = to, children, onClick } = props;\n\n  const handleClick = useCallback(\n    (event) => {\n      // ignores the navigation when clicked using right mouse button or\n      // by holding a special modifier key: ctrl, command, win, alt, shift\n      if (\n        event.ctrlKey ||\n        event.metaKey ||\n        event.altKey ||\n        event.shiftKey ||\n        event.button !== 0\n      )\n        return;\n\n      event.preventDefault();\n      navRef.current();\n      onClick && onClick(event);\n    },\n    // navRef is a ref so it never changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [onClick]\n  );\n\n  // wraps children in `a` if needed\n  const extraProps = { href: base + href, onClick: handleClick, to: null };\n  const jsx = isValidElement(children) ? children : h(\"a\", props);\n\n  return cloneElement(jsx, extraProps);\n};\n\nexport const Switch = ({ children, location }) => {\n  const { matcher } = useRouter();\n  const [originalLocation] = useLocation();\n\n  children = Array.isArray(children) ? children : [children];\n\n  for (const element of children) {\n    let match = 0;\n\n    if (\n      isValidElement(element) &&\n      // we don't require an element to be of type Route,\n      // but we do require it to contain a truthy `path` prop.\n      // this allows to use different components that wrap Route\n      // inside of a switch, for example <AnimatedRoute />.\n      (match = element.props.path\n        ? matcher(element.props.path, location || originalLocation)\n        : [true, {}])[0]\n    )\n      return cloneElement(element, { match });\n  }\n\n  return null;\n};\n\nexport const Redirect = (props) => {\n  const navRef = useNavigate(props);\n\n  // empty array means running the effect once, navRef is a ref so it never changes\n  useLayoutEffect(() => {\n    navRef.current();\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return null;\n};\n\nexport default useRoute;\n"]},"metadata":{},"sourceType":"module"}