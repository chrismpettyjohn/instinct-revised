{"ast":null,"code":"const url = require('native-url');\n\nconst getCurrentScriptSource = require('./getCurrentScriptSource');\n\nconst parseQuery = require('./parseQuery');\n/**\n * @typedef {Object} SocketUrlParts\n * @property {string} [auth]\n * @property {string} [hostname]\n * @property {string} [protocol]\n * @property {string} [pathname]\n * @property {string} [port]\n */\n\n/**\n * Parse current location and Webpack's `__resourceQuery` into parts that can create a valid socket URL.\n * @param {string} [resourceQuery] The Webpack `__resourceQuery` string.\n * @returns {SocketUrlParts} The parsed URL parts.\n * @see https://webpack.js.org/api/module-variables/#__resourcequery-webpack-specific\n */\n\n\nfunction getSocketUrlParts(resourceQuery) {\n  const scriptSource = getCurrentScriptSource();\n  const urlParts = url.parse(scriptSource);\n  /** @type {string | undefined} */\n\n  let auth;\n  let hostname = urlParts.hostname;\n  let protocol = urlParts.protocol;\n  let pathname = '/sockjs-node'; // This is hard-coded in WDS\n\n  let port = urlParts.port; // FIXME:\n  // This is a hack to work-around `native-url`'s parse method,\n  // which filters out falsy values when concatenating the `auth` string.\n  // In reality, we need to check for both values to correctly inject them.\n  // Ref: GoogleChromeLabs/native-url#32\n  // The placeholder `baseURL` is to allow parsing of relative paths,\n  // and will have no effect if `scriptSource` is a proper URL.\n\n  const authUrlParts = new URL(scriptSource, 'http://foo.bar'); // Parse authentication credentials in case we need them\n\n  if (authUrlParts.username) {\n    auth = authUrlParts.username; // Since HTTP basic authentication does not allow empty username,\n    // we only include password if the username is not empty.\n\n    if (authUrlParts.password) {\n      // Result: <username>:<password>\n      auth = auth.concat(':', authUrlParts.password);\n    }\n  } // Check for IPv4 and IPv6 host addresses that corresponds to `any`/`empty`.\n  // This is important because `hostname` can be empty for some hosts,\n  // such as `about:blank` or `file://` URLs.\n\n\n  const isEmptyHostname = urlParts.hostname === '0.0.0.0' || urlParts.hostname === '::' || urlParts.hostname === null; // We only re-assign the hostname if we are using HTTP/HTTPS protocols\n\n  if (isEmptyHostname && window.location.hostname && window.location.protocol.indexOf('http') !== -1) {\n    hostname = window.location.hostname;\n  } // We only re-assign `protocol` when `hostname` is available and is empty,\n  // since otherwise we risk creating an invalid URL.\n  // We also do this when `https` is used as it mandates the use of secure sockets.\n\n\n  if (hostname && (isEmptyHostname || window.location.protocol === 'https:')) {\n    protocol = window.location.protocol;\n  } // We only re-assign port when it is not available or `empty`\n\n\n  if (!port || port === '0') {\n    port = window.location.port;\n  } // If the resource query is available,\n  // parse it and overwrite everything we received from the script host.\n\n\n  const parsedQuery = parseQuery(resourceQuery || '');\n  hostname = parsedQuery.sockHost || hostname;\n  pathname = parsedQuery.sockPath || pathname;\n  port = parsedQuery.sockPort || port;\n  return {\n    auth: auth,\n    hostname: hostname,\n    pathname: pathname,\n    protocol: protocol,\n    port: port\n  };\n}\n\nmodule.exports = getSocketUrlParts;","map":{"version":3,"sources":["/Users/cpettyjohn/Habbo/instinct-revised/node_modules/@pmmmwh/react-refresh-webpack-plugin/sockets/utils/getSocketUrlParts.js"],"names":["url","require","getCurrentScriptSource","parseQuery","getSocketUrlParts","resourceQuery","scriptSource","urlParts","parse","auth","hostname","protocol","pathname","port","authUrlParts","URL","username","password","concat","isEmptyHostname","window","location","indexOf","parsedQuery","sockHost","sockPath","sockPort","module","exports"],"mappings":"AAAA,MAAMA,GAAG,GAAGC,OAAO,CAAC,YAAD,CAAnB;;AACA,MAAMC,sBAAsB,GAAGD,OAAO,CAAC,0BAAD,CAAtC;;AACA,MAAME,UAAU,GAAGF,OAAO,CAAC,cAAD,CAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,iBAAT,CAA2BC,aAA3B,EAA0C;AACxC,QAAMC,YAAY,GAAGJ,sBAAsB,EAA3C;AACA,QAAMK,QAAQ,GAAGP,GAAG,CAACQ,KAAJ,CAAUF,YAAV,CAAjB;AAEA;;AACA,MAAIG,IAAJ;AACA,MAAIC,QAAQ,GAAGH,QAAQ,CAACG,QAAxB;AACA,MAAIC,QAAQ,GAAGJ,QAAQ,CAACI,QAAxB;AACA,MAAIC,QAAQ,GAAG,cAAf,CARwC,CAQT;;AAC/B,MAAIC,IAAI,GAAGN,QAAQ,CAACM,IAApB,CATwC,CAWxC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAMC,YAAY,GAAG,IAAIC,GAAJ,CAAQT,YAAR,EAAsB,gBAAtB,CAArB,CAlBwC,CAmBxC;;AACA,MAAIQ,YAAY,CAACE,QAAjB,EAA2B;AACzBP,IAAAA,IAAI,GAAGK,YAAY,CAACE,QAApB,CADyB,CAGzB;AACA;;AACA,QAAIF,YAAY,CAACG,QAAjB,EAA2B;AACzB;AACAR,MAAAA,IAAI,GAAGA,IAAI,CAACS,MAAL,CAAY,GAAZ,EAAiBJ,YAAY,CAACG,QAA9B,CAAP;AACD;AACF,GA7BuC,CA+BxC;AACA;AACA;;;AACA,QAAME,eAAe,GACnBZ,QAAQ,CAACG,QAAT,KAAsB,SAAtB,IAAmCH,QAAQ,CAACG,QAAT,KAAsB,IAAzD,IAAiEH,QAAQ,CAACG,QAAT,KAAsB,IADzF,CAlCwC,CAqCxC;;AACA,MACES,eAAe,IACfC,MAAM,CAACC,QAAP,CAAgBX,QADhB,IAEAU,MAAM,CAACC,QAAP,CAAgBV,QAAhB,CAAyBW,OAAzB,CAAiC,MAAjC,MAA6C,CAAC,CAHhD,EAIE;AACAZ,IAAAA,QAAQ,GAAGU,MAAM,CAACC,QAAP,CAAgBX,QAA3B;AACD,GA5CuC,CA8CxC;AACA;AACA;;;AACA,MAAIA,QAAQ,KAAKS,eAAe,IAAIC,MAAM,CAACC,QAAP,CAAgBV,QAAhB,KAA6B,QAArD,CAAZ,EAA4E;AAC1EA,IAAAA,QAAQ,GAAGS,MAAM,CAACC,QAAP,CAAgBV,QAA3B;AACD,GAnDuC,CAqDxC;;;AACA,MAAI,CAACE,IAAD,IAASA,IAAI,KAAK,GAAtB,EAA2B;AACzBA,IAAAA,IAAI,GAAGO,MAAM,CAACC,QAAP,CAAgBR,IAAvB;AACD,GAxDuC,CA0DxC;AACA;;;AACA,QAAMU,WAAW,GAAGpB,UAAU,CAACE,aAAa,IAAI,EAAlB,CAA9B;AACAK,EAAAA,QAAQ,GAAGa,WAAW,CAACC,QAAZ,IAAwBd,QAAnC;AACAE,EAAAA,QAAQ,GAAGW,WAAW,CAACE,QAAZ,IAAwBb,QAAnC;AACAC,EAAAA,IAAI,GAAGU,WAAW,CAACG,QAAZ,IAAwBb,IAA/B;AAEA,SAAO;AACLJ,IAAAA,IAAI,EAAEA,IADD;AAELC,IAAAA,QAAQ,EAAEA,QAFL;AAGLE,IAAAA,QAAQ,EAAEA,QAHL;AAILD,IAAAA,QAAQ,EAAEA,QAJL;AAKLE,IAAAA,IAAI,EAAEA;AALD,GAAP;AAOD;;AAEDc,MAAM,CAACC,OAAP,GAAiBxB,iBAAjB","sourcesContent":["const url = require('native-url');\nconst getCurrentScriptSource = require('./getCurrentScriptSource');\nconst parseQuery = require('./parseQuery');\n\n/**\n * @typedef {Object} SocketUrlParts\n * @property {string} [auth]\n * @property {string} [hostname]\n * @property {string} [protocol]\n * @property {string} [pathname]\n * @property {string} [port]\n */\n\n/**\n * Parse current location and Webpack's `__resourceQuery` into parts that can create a valid socket URL.\n * @param {string} [resourceQuery] The Webpack `__resourceQuery` string.\n * @returns {SocketUrlParts} The parsed URL parts.\n * @see https://webpack.js.org/api/module-variables/#__resourcequery-webpack-specific\n */\nfunction getSocketUrlParts(resourceQuery) {\n  const scriptSource = getCurrentScriptSource();\n  const urlParts = url.parse(scriptSource);\n\n  /** @type {string | undefined} */\n  let auth;\n  let hostname = urlParts.hostname;\n  let protocol = urlParts.protocol;\n  let pathname = '/sockjs-node'; // This is hard-coded in WDS\n  let port = urlParts.port;\n\n  // FIXME:\n  // This is a hack to work-around `native-url`'s parse method,\n  // which filters out falsy values when concatenating the `auth` string.\n  // In reality, we need to check for both values to correctly inject them.\n  // Ref: GoogleChromeLabs/native-url#32\n  // The placeholder `baseURL` is to allow parsing of relative paths,\n  // and will have no effect if `scriptSource` is a proper URL.\n  const authUrlParts = new URL(scriptSource, 'http://foo.bar');\n  // Parse authentication credentials in case we need them\n  if (authUrlParts.username) {\n    auth = authUrlParts.username;\n\n    // Since HTTP basic authentication does not allow empty username,\n    // we only include password if the username is not empty.\n    if (authUrlParts.password) {\n      // Result: <username>:<password>\n      auth = auth.concat(':', authUrlParts.password);\n    }\n  }\n\n  // Check for IPv4 and IPv6 host addresses that corresponds to `any`/`empty`.\n  // This is important because `hostname` can be empty for some hosts,\n  // such as `about:blank` or `file://` URLs.\n  const isEmptyHostname =\n    urlParts.hostname === '0.0.0.0' || urlParts.hostname === '::' || urlParts.hostname === null;\n\n  // We only re-assign the hostname if we are using HTTP/HTTPS protocols\n  if (\n    isEmptyHostname &&\n    window.location.hostname &&\n    window.location.protocol.indexOf('http') !== -1\n  ) {\n    hostname = window.location.hostname;\n  }\n\n  // We only re-assign `protocol` when `hostname` is available and is empty,\n  // since otherwise we risk creating an invalid URL.\n  // We also do this when `https` is used as it mandates the use of secure sockets.\n  if (hostname && (isEmptyHostname || window.location.protocol === 'https:')) {\n    protocol = window.location.protocol;\n  }\n\n  // We only re-assign port when it is not available or `empty`\n  if (!port || port === '0') {\n    port = window.location.port;\n  }\n\n  // If the resource query is available,\n  // parse it and overwrite everything we received from the script host.\n  const parsedQuery = parseQuery(resourceQuery || '');\n  hostname = parsedQuery.sockHost || hostname;\n  pathname = parsedQuery.sockPath || pathname;\n  port = parsedQuery.sockPort || port;\n\n  return {\n    auth: auth,\n    hostname: hostname,\n    pathname: pathname,\n    protocol: protocol,\n    port: port,\n  };\n}\n\nmodule.exports = getSocketUrlParts;\n"]},"metadata":{},"sourceType":"script"}