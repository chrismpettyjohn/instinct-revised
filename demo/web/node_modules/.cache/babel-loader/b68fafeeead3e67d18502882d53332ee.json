{"ast":null,"code":"/* global __react_refresh_error_overlay__, __react_refresh_init_socket__, __resourceQuery */\nconst errorEventHandlers = require('./utils/errorEventHandlers');\n\nconst formatWebpackErrors = require('./utils/formatWebpackErrors'); // Setup error states\n\n\nlet isHotReload = false;\nlet hasRuntimeErrors = false;\n/**\n * Try dismissing the compile error overlay.\n * This will also reset runtime error records (if any),\n * because we have new source to evaluate.\n * @returns {void}\n */\n\nfunction tryDismissErrorOverlay() {\n  __react_refresh_error_overlay__.clearCompileError();\n\n  __react_refresh_error_overlay__.clearRuntimeErrors(!hasRuntimeErrors);\n\n  hasRuntimeErrors = false;\n}\n/**\n * A function called after a compile success signal is received from Webpack.\n * @returns {void}\n */\n\n\nfunction handleCompileSuccess() {\n  isHotReload = true;\n\n  if (isHotReload) {\n    tryDismissErrorOverlay();\n  }\n}\n/**\n * A function called after a compile errored signal is received from Webpack.\n * @param {string} errors\n * @returns {void}\n */\n\n\nfunction handleCompileErrors(errors) {\n  isHotReload = true;\n  const formattedErrors = formatWebpackErrors(errors); // Only show the first error\n\n  __react_refresh_error_overlay__.showCompileError(formattedErrors[0]);\n}\n/**\n * Handles compilation messages from Webpack.\n * Integrates with a compile error overlay.\n * @param {*} message A Webpack HMR message sent via WebSockets.\n * @returns {void}\n */\n\n\nfunction compileMessageHandler(message) {\n  switch (message.type) {\n    case 'ok':\n    case 'still-ok':\n    case 'warnings':\n      {\n        // TODO: Implement handling for warnings\n        handleCompileSuccess();\n        break;\n      }\n\n    case 'errors':\n      {\n        handleCompileErrors(message.data);\n        break;\n      }\n\n    default:\n      {// Do nothing.\n      }\n  }\n} // Only register if we're in non-production mode and if window is defined\n\n\nif (process.env.NODE_ENV !== 'production' && typeof window !== 'undefined') {\n  // Registers handlers for compile errors\n  __react_refresh_init_socket__(compileMessageHandler, __resourceQuery); // Registers handlers for runtime errors\n\n\n  errorEventHandlers.error(function handleError(error) {\n    hasRuntimeErrors = true;\n\n    __react_refresh_error_overlay__.handleRuntimeError(error);\n  });\n  errorEventHandlers.unhandledRejection(function handleUnhandledPromiseRejection(error) {\n    hasRuntimeErrors = true;\n\n    __react_refresh_error_overlay__.handleRuntimeError(error);\n  });\n}","map":{"version":3,"sources":["/Users/cpettyjohn/Habbo/instinct/node_modules/@pmmmwh/react-refresh-webpack-plugin/client/ErrorOverlayEntry.js"],"names":["errorEventHandlers","require","formatWebpackErrors","isHotReload","hasRuntimeErrors","tryDismissErrorOverlay","__react_refresh_error_overlay__","clearCompileError","clearRuntimeErrors","handleCompileSuccess","handleCompileErrors","errors","formattedErrors","showCompileError","compileMessageHandler","message","type","data","process","env","NODE_ENV","window","__react_refresh_init_socket__","__resourceQuery","error","handleError","handleRuntimeError","unhandledRejection","handleUnhandledPromiseRejection"],"mappings":"AAAA;AAEA,MAAMA,kBAAkB,GAAGC,OAAO,CAAC,4BAAD,CAAlC;;AACA,MAAMC,mBAAmB,GAAGD,OAAO,CAAC,6BAAD,CAAnC,C,CAEA;;;AACA,IAAIE,WAAW,GAAG,KAAlB;AACA,IAAIC,gBAAgB,GAAG,KAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,sBAAT,GAAkC;AAChCC,EAAAA,+BAA+B,CAACC,iBAAhC;;AACAD,EAAAA,+BAA+B,CAACE,kBAAhC,CAAmD,CAACJ,gBAApD;;AACAA,EAAAA,gBAAgB,GAAG,KAAnB;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASK,oBAAT,GAAgC;AAC9BN,EAAAA,WAAW,GAAG,IAAd;;AAEA,MAAIA,WAAJ,EAAiB;AACfE,IAAAA,sBAAsB;AACvB;AACF;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASK,mBAAT,CAA6BC,MAA7B,EAAqC;AACnCR,EAAAA,WAAW,GAAG,IAAd;AAEA,QAAMS,eAAe,GAAGV,mBAAmB,CAACS,MAAD,CAA3C,CAHmC,CAKnC;;AACAL,EAAAA,+BAA+B,CAACO,gBAAhC,CAAiDD,eAAe,CAAC,CAAD,CAAhE;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,qBAAT,CAA+BC,OAA/B,EAAwC;AACtC,UAAQA,OAAO,CAACC,IAAhB;AACE,SAAK,IAAL;AACA,SAAK,UAAL;AACA,SAAK,UAAL;AAAiB;AACf;AACAP,QAAAA,oBAAoB;AACpB;AACD;;AACD,SAAK,QAAL;AAAe;AACbC,QAAAA,mBAAmB,CAACK,OAAO,CAACE,IAAT,CAAnB;AACA;AACD;;AACD;AAAS,OACP;AACD;AAdH;AAgBD,C,CAED;;;AACA,IAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,IAAyC,OAAOC,MAAP,KAAkB,WAA/D,EAA4E;AAC1E;AACAC,EAAAA,6BAA6B,CAACR,qBAAD,EAAwBS,eAAxB,CAA7B,CAF0E,CAG1E;;;AACAvB,EAAAA,kBAAkB,CAACwB,KAAnB,CAAyB,SAASC,WAAT,CAAqBD,KAArB,EAA4B;AACnDpB,IAAAA,gBAAgB,GAAG,IAAnB;;AACAE,IAAAA,+BAA+B,CAACoB,kBAAhC,CAAmDF,KAAnD;AACD,GAHD;AAIAxB,EAAAA,kBAAkB,CAAC2B,kBAAnB,CAAsC,SAASC,+BAAT,CAAyCJ,KAAzC,EAAgD;AACpFpB,IAAAA,gBAAgB,GAAG,IAAnB;;AACAE,IAAAA,+BAA+B,CAACoB,kBAAhC,CAAmDF,KAAnD;AACD,GAHD;AAID","sourcesContent":["/* global __react_refresh_error_overlay__, __react_refresh_init_socket__, __resourceQuery */\n\nconst errorEventHandlers = require('./utils/errorEventHandlers');\nconst formatWebpackErrors = require('./utils/formatWebpackErrors');\n\n// Setup error states\nlet isHotReload = false;\nlet hasRuntimeErrors = false;\n\n/**\n * Try dismissing the compile error overlay.\n * This will also reset runtime error records (if any),\n * because we have new source to evaluate.\n * @returns {void}\n */\nfunction tryDismissErrorOverlay() {\n  __react_refresh_error_overlay__.clearCompileError();\n  __react_refresh_error_overlay__.clearRuntimeErrors(!hasRuntimeErrors);\n  hasRuntimeErrors = false;\n}\n\n/**\n * A function called after a compile success signal is received from Webpack.\n * @returns {void}\n */\nfunction handleCompileSuccess() {\n  isHotReload = true;\n\n  if (isHotReload) {\n    tryDismissErrorOverlay();\n  }\n}\n\n/**\n * A function called after a compile errored signal is received from Webpack.\n * @param {string} errors\n * @returns {void}\n */\nfunction handleCompileErrors(errors) {\n  isHotReload = true;\n\n  const formattedErrors = formatWebpackErrors(errors);\n\n  // Only show the first error\n  __react_refresh_error_overlay__.showCompileError(formattedErrors[0]);\n}\n\n/**\n * Handles compilation messages from Webpack.\n * Integrates with a compile error overlay.\n * @param {*} message A Webpack HMR message sent via WebSockets.\n * @returns {void}\n */\nfunction compileMessageHandler(message) {\n  switch (message.type) {\n    case 'ok':\n    case 'still-ok':\n    case 'warnings': {\n      // TODO: Implement handling for warnings\n      handleCompileSuccess();\n      break;\n    }\n    case 'errors': {\n      handleCompileErrors(message.data);\n      break;\n    }\n    default: {\n      // Do nothing.\n    }\n  }\n}\n\n// Only register if we're in non-production mode and if window is defined\nif (process.env.NODE_ENV !== 'production' && typeof window !== 'undefined') {\n  // Registers handlers for compile errors\n  __react_refresh_init_socket__(compileMessageHandler, __resourceQuery);\n  // Registers handlers for runtime errors\n  errorEventHandlers.error(function handleError(error) {\n    hasRuntimeErrors = true;\n    __react_refresh_error_overlay__.handleRuntimeError(error);\n  });\n  errorEventHandlers.unhandledRejection(function handleUnhandledPromiseRejection(error) {\n    hasRuntimeErrors = true;\n    __react_refresh_error_overlay__.handleRuntimeError(error);\n  });\n}\n"]},"metadata":{},"sourceType":"script"}